<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>MNIST 手写数字识别 · 矩阵乘法可视化</title>
    <link rel="icon" type="image/png" href="catt.png?v=2">

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f3f4f6;
      color: #111827;
    }
    header {
      background: #111827;
      color: #f9fafb;
      padding: 16px 24px;
    }
    header h1 {
      margin: 0 0 4px;
      font-size: 20px;
    }
    header p {
      margin: 0;
      font-size: 13px;
      opacity: 0.8;
    }
    main {
      padding: 16px 24px 40px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .col {
      display: flex;
      flex-direction: column;
      justify-content: center; /* 垂直居中这一列里的内容 */
    }
    .panel {
      background: white;
      border-radius: 12px;
      padding: 16px 16px 20px;
      margin-top: 12px;
      box-shadow: 0 8px 20px rgba(15,23,42,0.06);
    }
    .step-label {
      font-size: 13px;
      font-weight: 600;
      color: #6b7280;
      /* text-transform: uppercase; */
      letter-spacing: .08em;
      margin-bottom: 4px;
    }
    .muted {
      color: #6b7280;
      font-size: 12px;
    }
    .flex-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }
    .sample-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .sample-card {
      border-radius: 10px;
      padding: 8px;
      border: 2px solid transparent;
      background: #f9fafb;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      min-width: 70px;
      transition: all .12s ease-out;
    }
    .sample-card.selected {
      border-color: #2563eb;
      background: #eff6ff;
      box-shadow: 0 0 0 1px rgba(37,99,235,0.25);
    }
    .sample-card span {
      font-size: 12px;
      color: #374151;
    }
    canvas {
      image-rendering: pixelated;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      background: white;
      display: block; 
      /* center */
      margin: 0 auto;
    }
    .arrow {
      font-size: 24px;
      margin: auto 4px;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 999px;
      background: #eff6ff;
      color: #1d4ed8;
      font-size: 11px;
      font-weight: 500;
      gap: 4px;
      margin-bottom: 4px;
      margin-top:8px;
    }
    .highlight {
      color: #2563eb;
      font-weight: 600;
    }
    .matrix-info {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      background: #f9fafb;
      border-radius: 8px;
      padding: 8px 10px;
      margin-top: 8px;
      white-space: pre-wrap;
    }
    .btn {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #2563eb;
      color: white;
      box-shadow: 0 8px 14px rgba(37,99,235,0.25);
      transition: all .12s ease-out;
      margin-right: 6px;
      margin-bottom: 6px;
    }
    .btn.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }
    .btn:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 20px rgba(37,99,235,0.35);
    }
    .btn.secondary:not(:disabled):hover {
      box-shadow: 0 8px 18px rgba(148,163,184,0.4);
    }
    .output-bars {
      display: flex;
      align-items: flex-end;
      gap: 8px;
      height: 150px;
      padding: 6px 0;
    }
    .bar {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 11px;
    }
    .bar-inner {
      width: 100%;
      border-radius: 999px 999px 4px 4px;
      background: #d1d5db;
      transition: height .18s ease-out, background .18s ease-out;
    }
    .bar-inner.active {
      background: #2563eb;
    }
    .bar-label {
      margin-top: 4px;
    }
    code {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
    }
    @media (max-width: 900px) {
      .flex-row {
        flex-direction: column;
      }
    }
  </style>

    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header>
  <h1>MNIST 手写数字识别 · 矩阵乘法可视化</h1>
  <p>演示 \( \mathbf{I} \in M_{28 \times 28} (\mathbb{R}) \) 图像 → \( \mathbf{x} \in M_{784 \times 1} (\mathbb{R}) \) 展开向量 → 全连接层矩阵乘法 → 预测概率 \( \hat{\mathbf{y}} \in M_{10 \times 1} (\mathbb{R}) \) 输出的全过程。</p>
</header>

<main>
  <!-- STEP 1: 选择样本 -->
  <section class="panel">
    <div class="step-label">Step 1 · 选择一张 MNIST 数字图像</div>
    <div id="sampleList" class="sample-list"></div>
  </section>

  <!-- STEP 2: 28×28 => 784×1 -->
  <section class="panel">
    <div class="step-label">Step 2 · \( \mathbf{I} \in M_{28 \times 28} (\mathbb{R}) \) 矩阵展平成 \( \mathbf{x} \in M_{784 \times 1} (\mathbb{R}) \) 列向量</div>
        <div class="flex-row">
            <div>
              <canvas id="imageCanvas" width="140" height="140"></canvas>
                <div class="pill">原始图像 \( \mathbf{I} \in M_{28 \times 28} (\mathbb{R}) \)</div>
                
            </div>
            <div class="arrow">→</div>
            <div>
              <canvas id="flatRowCanvas" width="220" height="30"></canvas>
                <div class="pill">展平后的行向量 \( \mathbf{x}^T \in M_{1 \times 784} (\mathbb{R}) \)</div>
                
            </div>
            <div class="arrow">→</div>
            <div>
              <canvas id="flatCanvas" width="30" height="220"></canvas>
                <div class="pill">作为列向量的 \( \mathbf{x} \in M_{784 \times 1} (\mathbb{R}) \)</div>
                
            </div>
        </div>
              <p class="muted">
                展平方式：按 <span class="highlight">行</span> 展平。<br>
                可先看作 \( \mathbf{x}^T \in M_{1 \times 784} (\mathbb{R}) \) 的行向量，再转置为 \( \mathbf{x} \in M_{784 \times 1} (\mathbb{R}) \) 列向量参与矩阵乘法。
              </p>
  </section>

    <!-- 放在 Step 3 前面 -->
  <section class="panel">
    <div class="step-label">STEP 3 · 权重模式</div>
    <p class="muted">
      - 随机初始化：用于展示「模型还没学会时」的矩阵乘法效果<br>
      - 训练好的权重：用于展示真实识别效果
    </p>
    <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap;">
      <div>
        <label><input type="radio" name="wmode" value="random" checked> 随机初始化</label><br>
        <label><input type="radio" name="wmode" value="trained"> 使用训练好的权重</label>
      </div>
      <div id="modeTag"
           style="padding:6px 10px;border-radius:999px;background:#eff6ff;color:#1d4ed8;font-size:12px;">
        当前：随机初始化权重
      </div>
    </div>
  </section>


  <!-- STEP 3: 第一层矩阵乘法 -->
  <section class="panel">
    <div class="step-label">STEP 4 · 第一层全连接：\( \mathbf{W}_1 \cdot \mathbf{x} + \mathbf{b}_1 \)</div>
<p class="muted">
  第一层维度：
  \( \mathbf{W}_1 \in M_{16 \times 784} (\mathbb{R}) \),
  \( \mathbf{b}_1 \in M_{16 \times 1} (\mathbb{R}) \), 
  激活函数 \( \text{ReLU} \)。<br>
</p>

    <button id="btnInit" class="btn">初始化/加载权重并计算第一层</button>
    <button id="btnShowNeuron" class="btn secondary" disabled>展示第一个神经元的计算公式</button>

    <div class="flex-row" style="margin-top:12px;">
      <div>
        <canvas id="xCanvas" width="30" height="220"></canvas>
        <div class="pill">输入向量 \( \mathbf{x} \in M_{784 \times 1} (\mathbb{R}) \)</div>
      </div>

      <div>
        <canvas id="W1Canvas" width="260" height="130"></canvas>
        <div class="pill">权重矩阵 \( \mathbf{W}_1 \in M_{16 \times 784} (\mathbb{R}) \)</div>
      </div>

      <div>
        <canvas id="h1LinearCanvas" width="30" height="130"></canvas>
        <div class="pill">
          线性输出 \( \mathbf{h}_1 = \mathbf{W}_1 \cdot \mathbf{x} + \mathbf{b}_1 \in M_{16 \times 1} (\mathbb{R}) \)
        </div>
      </div>

      <div>
        <canvas id="h1ReluCanvas" width="30" height="130"></canvas>
        <div class="pill">\( \text{ReLU}(\mathbf{h}_1) \)</div>
      </div>
    </div>

    <div id="layer1Info" class="matrix-info"></div>
    <div id="neuronInfo" class="matrix-info"></div>
  </section>

  <!-- STEP 4: 第二层 + 输出 -->
  <section class="panel">
    <div class="step-label">STEP 5 · 第二层全连接 + Softmax </div>
    <p class="muted">
      第二层：\( \mathbf{W}_2 \in M_{10 \times 16} (\mathbb{R}) \),
      \( \mathbf{b}_2 \in M_{10 \times 1} (\mathbb{R}) \)。<br>
      \( \mathbf{h}_2 = \mathbf{W}_2 \cdot \mathbf{h}_1 + \mathbf{b}_2\) ,
      \(\hat{\mathbf{y}} = \text{softmax}(\mathbf{h}_2) \)，
      其中 \( \hat{\mathbf{y}} \) 的 10 个分量对应数字 0–9 的概率。
    </p>

    <button id="btnForwardAll" class="btn" disabled>计算第二层并展示最终输出</button>

    <div id="layer2Info" class="matrix-info"></div>
    <div id="logitsInfo" class="matrix-info"></div>

    <div class="pill" style="margin-top:8px;">Softmax 输出：每个数字的概率柱状图</div>
    <div id="outputBars" class="output-bars"></div>
  </section>
</main>

<script>
  // ========= 全局状态 =========
  let mnistSamples = [];
  let trainedWeights = null;
  let currentSample = null;

  let W1 = null, b1 = null, W2 = null, b2 = null;
  let xVector = null;         // 784×1，已归一化
  let linearH1 = null;        // 未 ReLU 的 16×1
  let h1 = null;              // ReLU 后的 16×1
  let logits = null;          // 10×1
  let probs  = null;          // 10×1

  // ========= 工具函数 =========
  function relu(x) { return Math.max(0, x); }

  function softmax(vec) {
    const maxVal = Math.max(...vec);
    const exps = vec.map(v => Math.exp(v - maxVal));
    const sum = exps.reduce((a,b) => a + b, 0);
    return exps.map(v => v / sum);
  }

  function toGray(v, minVal, maxVal) {
    if (maxVal === minVal) return 128;
    const t = (v - minVal) / (maxVal - minVal); // 0..1
    const g = Math.round(255 * (1 - t));        // 大值 -> 深色
    return g;
  }

  // 简单随机权重初始化
  function initRandomWeights() {
    const inputDim = 784;
    const hiddenDim = 16;
    const outputDim = 10;
    W1 = new Array(hiddenDim).fill(0).map(
      () => new Array(inputDim).fill(0).map(() => (Math.random() - 0.5) * 0.2)
    );
    b1 = new Array(hiddenDim).fill(0).map(() => (Math.random() - 0.5) * 0.1);
    W2 = new Array(outputDim).fill(0).map(
      () => new Array(hiddenDim).fill(0).map(() => (Math.random() - 0.5) * 0.2)
    );
    b2 = new Array(outputDim).fill(0).map(() => (Math.random() - 0.5) * 0.1);
  }

  function updateModeFromUI() {
    const radios = document.querySelectorAll('input[name="wmode"]');
    for (const r of radios) {
      if (r.checked) return r.value;
    }
    return 'random';
  }

function initWeightsDependingOnMode() {
const mode = updateModeFromUI();
const modeTag = document.getElementById("modeTag");
if (mode === 'random') {
    initRandomWeights();
    if (modeTag) modeTag.textContent = "当前：随机初始化权重";
} else {
    W1 = trainedWeights.W1;
    b1 = trainedWeights.b1;
    W2 = trainedWeights.W2;
    b2 = trainedWeights.b2;
    if (modeTag) modeTag.textContent = "当前：使用训练好的权重";
}
}

  // ========= MNIST 图像绘制 =========
  function drawImage(sample) {
    const canvas = document.getElementById("imageCanvas");
    const ctx = canvas.getContext("2d");
    const W = sample.width;
    const H = sample.height;
    const cell = canvas.width / W;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let i = 0; i < H; i++) {
      for (let j = 0; j < W; j++) {
        const idx = i * W + j;
        const v = sample.pixels[idx]; // 0..255
        const g = 255 - v; // 白底黑字
        ctx.fillStyle = `rgb(${g},${g},${g})`;
        ctx.fillRect(j*cell, i*cell, cell, cell);
      }
    }
  }

//   // 按列展平（column-major）
//   function getFlattenColumnMajor(sample) {
//     const { width: W, height: H, pixels } = sample;
//     const x = [];
//     for (let col = 0; col < W; col++) {
//       for (let row = 0; row < H; row++) {
//         const idx = row * W + col;
//         x.push(pixels[idx] / 255.0); // 归一化
//       }
//     }
//     return x; // 长度 784
//   }
function getFlattenRowMajor(sample) {
  const { width: W, height: H, pixels } = sample;
  const x = [];
  for (let row = 0; row < H; row++) {
    for (let col = 0; col < W; col++) {
      const idx = row * W + col;     // 逐行读像素
      x.push(pixels[idx] / 255.0);   // 归一化到 0~1
    }
  }
  return x; // 长度 784
}

  function drawFlatVector(sample) {
    const canvas = document.getElementById("flatCanvas");
    const ctx = canvas.getContext("2d");
    const x = getFlattenRowMajor(sample);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const n = x.length;
    for (let k = 0; k < n; k++) {
      const y = k / n * canvas.height;
      const h = Math.max(1, canvas.height / n);
      const g = toGray(x[k], 0, 1);
      ctx.fillStyle = `rgb(${g},${g},${g})`;
      ctx.fillRect(0, y, canvas.width, h);
    }
  }

  function drawFlatRowVector(sample) {
  const canvas = document.getElementById("flatRowCanvas");
  const ctx = canvas.getContext("2d");
  const x = getFlattenRowMajor(sample);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const n = x.length;
  for (let k = 0; k < n; k++) {
    const xPos = k / n * canvas.width;
    const w = Math.max(1, canvas.width / n);
    const g = toGray(x[k], 0, 1);
    ctx.fillStyle = `rgb(${g},${g},${g})`;
    ctx.fillRect(xPos, 0, w, canvas.height);
  }
}

  // ========= Step 3 可视化：x, W1, h1 =========
  function drawXVector() {
    const canvas = document.getElementById("xCanvas");
    const ctx = canvas.getContext("2d");
    const x = xVector;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const n = x.length;
    for (let k = 0; k < n; k++) {
      const y = k / n * canvas.height;
      const h = Math.max(1, canvas.height / n);
      const g = toGray(x[k], 0, 1);
      ctx.fillStyle = `rgb(${g},${g},${g})`;
      ctx.fillRect(0, y, canvas.width, h);
    }
  }

  function drawW1Matrix() {
    const canvas = document.getElementById("W1Canvas");
    const ctx = canvas.getContext("2d");
    const rows = W1.length;      // 16
    const cols = W1[0].length;   // 784
    let minVal = Infinity, maxVal = -Infinity;
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const v = W1[i][j];
        if (v < minVal) minVal = v;
        if (v > maxVal) maxVal = v;
      }
    }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const v = W1[i][j];
        const g = toGray(v, minVal, maxVal);
        const x = j / cols * canvas.width;
        const y = i / rows * canvas.height;
        const w = Math.ceil(canvas.width / cols);
        const h = Math.ceil(canvas.height / rows);
        ctx.fillStyle = `rgb(${g},${g},${g})`;
        ctx.fillRect(x, y, w, h);
      }
    }
  }

  function drawH1LinearAndRelu() {
    const linearCanvas = document.getElementById("h1LinearCanvas");
    const reluCanvas   = document.getElementById("h1ReluCanvas");
    const ctxL = linearCanvas.getContext("2d");
    const ctxR = reluCanvas.getContext("2d");
    const rows = linearH1.length;

    const minL = Math.min(...linearH1);
    const maxL = Math.max(...linearH1);
    const minR = 0;
    const maxR = Math.max(...h1) || 1;

    ctxL.clearRect(0,0,linearCanvas.width,linearCanvas.height);
    ctxR.clearRect(0,0,reluCanvas.width,reluCanvas.height);

    for (let i = 0; i < rows; i++) {
      const yL = i / rows * linearCanvas.height;
      const hL = Math.ceil(linearCanvas.height / rows);
      const gL = toGray(linearH1[i], minL, maxL);
      ctxL.fillStyle = `rgb(${gL},${gL},${gL})`;
      ctxL.fillRect(0, yL, linearCanvas.width, hL);

      const yR = i / rows * reluCanvas.height;
      const hR = Math.ceil(reluCanvas.height / rows);
      const gR = toGray(h1[i], minR, maxR);
      ctxR.fillStyle = `rgb(${gR},${gR},${gR})`;
      ctxR.fillRect(0, yR, reluCanvas.width, hR);
    }
  }

  // ========= 前向计算 =========
  function computeFirstLayer() {
    xVector = getFlattenRowMajor(currentSample); // 784×1
    const hiddenDim = W1.length;

    linearH1 = new Array(hiddenDim).fill(0);
    h1       = new Array(hiddenDim).fill(0);

    for (let i = 0; i < hiddenDim; i++) {
      let sum = b1[i];
      for (let j = 0; j < xVector.length; j++) {
        sum += W1[i][j] * xVector[j];
      }
      linearH1[i] = sum;
      h1[i] = relu(sum);
    }
  }

function showLayer1Info() {
  const info = document.getElementById("layer1Info");
  info.innerHTML = `
    第一层计算：<br>
    \\( \\mathbf{h}_1 = \\text{ReLU}(\\mathbf{W}_1 \\cdot \\mathbf{x} + \\mathbf{b}_1) \\)<br>
    其中：<br>
    \\( \\mathbf{W}_1 \\in M_{16 \\times 784}(\\mathbb{R}),\\
      \\mathbf{x} \\in M_{784 \\times 1}(\\mathbb{R}),\\
      \\mathbf{b}_1 \\in M_{16 \\times 1}(\\mathbb{R}),\\
      \\mathbf{h}_1 \\in M_{16 \\times 1}(\\mathbb{R}) \\)
  `;

  // 让 MathJax 重新渲染这一块
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([info]);
  } else if (window.MathJax && MathJax.typeset) {
    MathJax.typeset([info]);
  }
}

function showFirstNeuronDetail() {
  const info = document.getElementById("neuronInfo");

  // 前 8 项写成 LaTeX 形式 w_{1}[0,j] x[j]
  const termsLatex = [];
  for (let j = 0; j < 8; j++) {
    termsLatex.push(`\\mathbf{W}_{1}[0,${j}]\\, \\mathbf{x}[${j}]`);
  }

  info.innerHTML = `
    以第一个隐藏神经元 \\( \\mathbf{h}_1[0] \\) 为例：<br><br>
    \\[
      \\mathbf{h}_1[0] = \\mathrm{ReLU}\\left( \\sum_{j=0}^{783} \\mathbf{W}_{1}[0,j]\, \\mathbf{x}[j] + \\mathbf{b}_1[0] \\right)
    \\]
    展开前几项可写成：<br>
    \\[
      \\mathbf{h}_1[0] = \\mathrm{ReLU}\\big( ${termsLatex.join(" + ")} + \\dots + \\mathbf{b}_1[0] \\big)
    \\]
  `;

  // 让 MathJax 对这一块重新排版
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([info]);
  } else if (window.MathJax && MathJax.typeset) {
    MathJax.typeset([info]);
  }
}


  function forwardSecondLayer() {
    const hiddenDim = h1.length;
    const outputDim = W2.length;
    logits = new Array(outputDim).fill(0);

    for (let i = 0; i < outputDim; i++) {
      let sum = b2[i];
      for (let j = 0; j < hiddenDim; j++) {
        sum += W2[i][j] * h1[j];
      }
      logits[i] = sum;
    }
    probs = softmax(logits);
  }

function showLayer2Info() {
  const info = document.getElementById("layer2Info");
  const logitsInfo = document.getElementById("logitsInfo");

  // 上半部分：公式用 MathJax 渲染
  info.innerHTML = `
    第二层计算：<br>
    \\( \\mathbf{h}_2 = \\mathbf{W}_2 \\cdot \\mathbf{h}_1 + \\mathbf{b}_2 \\)<br>
    \\( \\hat{\\mathbf{y}} = \\mathrm{softmax}(\\mathbf{h}_2) \\)<br>
    其中：<br>
    \\( \\mathbf{W}_2 \\in M_{10 \\times 16}(\\mathbb{R}),\\
      \\mathbf{b}_2 \\in M_{10 \\times 1}(\\mathbb{R}),\\
      \\mathbf{h}_2, \\hat{\\mathbf{y}} \\in M_{10 \\times 1}(\\mathbb{R}) \\)。
  `;

  // 触发 MathJax 只重新排版这一块
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([info]);
  } else if (window.MathJax && MathJax.typeset) {
    MathJax.typeset([info]);
  }

  // 下半部分：logits 和 softmax 结果，普通文本显示就够了
  logitsInfo.innerHTML =
    "    logits（未归一化得分）: " +
    "[" + logits.map(v => v.toFixed(3)).join(", ") + "]\n\n" +
    "    softmax 概率: " +
    "[" + probs.map(v => v.toFixed(3)).join(", ") + "]";
}


  function showOutputBars() {
    const container = document.getElementById("outputBars");
    container.innerHTML = "";
    const maxP = Math.max(...probs);
    probs.forEach((p, digit) => {
      const bar = document.createElement("div");
      bar.className = "bar";

      const inner = document.createElement("div");
      inner.className = "bar-inner" + (p === maxP ? " active" : "");
      inner.style.height = (p * 130 + 4) + "px";
      bar.appendChild(inner);

      const label = document.createElement("div");
      label.className = "bar-label";
      label.textContent = digit.toString();
      bar.appendChild(label);

      const val = document.createElement("div");
      val.className = "muted";
      val.textContent = p.toFixed(2);
      bar.appendChild(val);

      container.appendChild(bar);
    });
  }

  // ========= UI 初始化 =========
  async function loadData() {
    const [samplesRes, weightsRes] = await Promise.all([
      fetch('mnist_samples.json'),
      fetch('mlp_weights.json')
    ]);
    mnistSamples = await samplesRes.json();
    trainedWeights = await weightsRes.json();
  }

  function renderSamples() {
    const list = document.getElementById("sampleList");
    list.innerHTML = "";
    mnistSamples.forEach((s, idx) => {
      const card = document.createElement("div");
      card.className = "sample-card" + (idx === 0 ? " selected" : "");
      card.dataset.index = idx;

      const thumbSize = 42;
      const canvas = document.createElement("canvas");
      canvas.width = thumbSize;
      canvas.height = thumbSize;
      const ctx = canvas.getContext("2d");
      const W = s.width, H = s.height;
      const cell = thumbSize / W;
      for (let i = 0; i < H; i++) {
        for (let j = 0; j < W; j++) {
          const idxPix = i * W + j;
          const v = s.pixels[idxPix];
          const g = 255 - v;
          ctx.fillStyle = `rgb(${g},${g},${g})`;
          ctx.fillRect(j*cell, i*cell, cell, cell);
        }
      }
      card.appendChild(canvas);

      const label = document.createElement("span");
      label.textContent = `数字 ${s.label}`;
      card.appendChild(label);

      card.onclick = () => {
        [...document.querySelectorAll(".sample-card")]
          .forEach(el => el.classList.remove("selected"));
        card.classList.add("selected");
        currentSample = s;
        drawImage(currentSample);
        drawFlatRowVector(currentSample);
        drawFlatVector(currentSample);
        // 切换样本后：清空后续可视化
        document.getElementById("layer1Info").textContent = "";
        document.getElementById("neuronInfo").textContent = "";
        document.getElementById("layer2Info").textContent = "";
        document.getElementById("logitsInfo").textContent = "";
        document.getElementById("outputBars").innerHTML = "";
      };

      list.appendChild(card);
    });
  }

  async function initApp() {
    await loadData();
    currentSample = mnistSamples[0];

    renderSamples();
    drawImage(currentSample);
    drawFlatRowVector(currentSample);
    drawFlatVector(currentSample);

    const btnInit = document.getElementById("btnInit");
    const btnNeuron = document.getElementById("btnShowNeuron");
    const btnForward = document.getElementById("btnForwardAll");

    btnInit.onclick = () => {
      initWeightsDependingOnMode();
      computeFirstLayer();
      drawFlatVector(currentSample); // Step2 的
      drawXVector();
      drawW1Matrix();
      drawH1LinearAndRelu();
      showLayer1Info();
      btnNeuron.disabled = false;
      btnForward.disabled = false;
    };

    btnNeuron.onclick = () => {
      if (!h1) return;
      showFirstNeuronDetail();
    };

    btnForward.onclick = () => {
      if (!h1) return;
      forwardSecondLayer();
      showLayer2Info();
      showOutputBars();
    };

  // 监听权重模式单选框的变化，仅更新显示，不重新初始化权重
  const modeRadios = document.querySelectorAll('input[name="wmode"]');
  const modeTag = document.getElementById("modeTag");
  modeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      const mode = updateModeFromUI();
      if (!modeTag) return;
      if (mode === 'random') {
        modeTag.textContent = "当前：随机初始化权重";
      } else {
        modeTag.textContent = "当前：使用训练好的权重";
      }
    });
  });


  }

  window.addEventListener('load', () => {
    initApp().catch(err => {
      console.error(err);
      alert("加载 mnist_samples.json 或 mlp_weights.json 失败，请检查文件是否在同一目录。");
    });
  });
</script>
</body>
</html>
